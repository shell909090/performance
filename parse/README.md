# 问题和算法描述 #

测试正则表达式解析速度。

制作一个测试文件，1M行。每行两个数，空格分隔。第一个数顺序增加，第二个数随机。要求程序利用正则表达式解析这个文件。

# 结果 #

+------+--------+-------+------+-------------+
| lang |filesize|runtime|memory|remark       |
+------+--------+-------+------+-------------+
|go    |1101k   |  5.8s |  968k|             |
+------+--------+-------+------+-------------+
|lua   |        |  1.34s|  784k|             |
+------+--------+-------+------+-------------+
|python|        |  0.92s| 3984k|             |
+------+--------+-------+------+-------------+
|cython|  19k   |  1.25s| 4056k|             |
+------+--------+-------+------+-------------+
|pypy  |        |  0.66s|15076k|             |
+------+--------+-------+------+-------------+
|guile |        | 15.6s | 5312k|             |
+------+--------+-------+------+-------------+
|racket|        |  1.8s |31832k|编译后更慢   |
+------+--------+-------+------+-------------+
|sbcl  |        |  0.39s|37456k|             |
+------+--------+-------+------+-------------+

## 分析 ##

这次的结果和上面很不一样，go的速度优势一点都没有显现。有篇文章解释了这个现象，据说这是因为go的正则是用go写的，而python的正则是C写的。这次测试的性能，其实是库的优秀程度。

而且racket里，编译后速度反而下降了0.2s。

速度：

1. 最快的是sbcl，一点不需要优化。这是因为sbcl用的正则库是lisp写的，在使用的时候其实是用宏编译到了一起。不过内存占用吓人了点。
2. 次之是pypy，不愧是专业优化过的。一样，内存占用是大问题。
3. python，速度不慢。内存占用比较好接受。
4. cython，和python的内存占用差不多。
5. lua，速度一般，内存占用最优。
6. racket，速度不快，内存占用很大。

剩下两个，guile和go，就是废柴了。我们可以看到，在做这种事情的时候，最佳选择其实是python。
