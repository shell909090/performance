# 问题和算法描述 #

测试正则表达式解析速度。

制作一个测试文件，1M行。每行两个数，空格分隔。第一个数顺序增加，第二个数随机。要求程序利用正则表达式解析这个文件。

# 结果 #

+--------+----------+---------+---------+--------+
|  lang  | filesize | runtime |  memory | remark |
+--------+----------+---------+---------+--------+
|  grep  |   171.0  |  0.015  |  1024.0 |        |
|  pypy  | 40066.0  |  0.443  | 19572.0 |        |
| python |  2931.0  |  0.855  |  5352.0 |        |
| cython |   26.0   |  1.018  |  5340.0 |        |
| racket |   26.0   |  1.031  |  5340.0 |        |
|  lua   |  190.0   |  1.111  |  1260.0 |        |
|  sbcl  |  218.0   |  1.534  | 88060.0 |        |
|   go   |  1145.0  |   3.55  |  1264.0 |        |
| guile  |   5.0    |  13.112 |  7268.0 |        |
+--------+----------+---------+---------+--------+

## 分析 ##

这次的结果和上面很不一样，go的速度优势一点都没有显现。有篇文章解释了这个现象，据说这是因为go的正则是用go写的，而python的正则是C写的。这次测试的性能，其实是库的优秀程度。

而且racket里，编译后速度反而下降了0.2s。

速度：

1. 最快的是grep，经过专门设计的系统，用C实现就是没的说啊。
2. 语言中最快的是pypy，这说明pypy的正则库经过专门编译。
3. python第三，说明python的库也经过相当优化，虽然grep比他快60倍。
4. cython，比python慢。这不奇怪，凡是没有运行优化，仅仅转换语法的地方，cython都比python慢。
5. racket/lua/sbcl，库实现的还不错啦。就是sbcl的内存消耗又吓到了。据说是因为sbcl用的正则库是lisp写的，在使用的时候其实是用宏编译到了一起。
6. go。不说了，伤心呐。

剩下guile，就是废柴了。我们可以看到，在做这种事情的时候，最佳选择其实是python。
