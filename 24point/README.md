# 问题和算法描述 #

计算24点。

算法为递归枚举。在可选择的数集合中选择一个数（注意，枚举时不能两次重复选择相同的数，哪怕 在数列集合中出现两次），在算符表中选择一个算符。利用算符，当前值，选择的数，拼出表达式和计算结果，再递归调用自身。

尤其注意结果值的传递，这会大量减轻算法时间消耗。

# 测试三：24点 #

测试操作符为+-*/，测试数据为3 4 5 6 7 8。

+--------+----------+---------+---------+--------+
|  lang  | filesize | runtime |  memory | remark |
+--------+----------+---------+---------+--------+
| cython |   53.0   |  0.037  |  5384.0 |        |
|  sbcl  |  218.0   |  0.043  | 17932.0 |        |
| racket |  4022.0  |  0.408  | 58512.0 |        |
|  pypy  | 40066.0  |  1.816  | 32064.0 |        |
|   go   |  1264.0  |  3.347  |  1692.0 |        |
|  lua   |  190.0   |  7.475  |  1060.0 |        |
| python |  2931.0  |   7.64  |  5512.0 |        |
+--------+----------+---------+---------+--------+

## 分析 ##

这次又是一个运算密集型问题，比较典型。其实对于这种问题，最好的是用lisp系的语言，例如sbcl和racket。

1. cython。去掉了C，cython就是常备冠军了。
2. sbcl。不知道为什么，sbcl在这里异常的快。我检查过内容，确实是对的。内存消耗比racket也还好。
3. racket。同上，不过慢了一个数量级。就是内存消耗异常的大。
4. pypy。出乎我的意料，pypy快的吓人。不过一样，内存是永远的伤。
5. go。最奇怪的就是go，我本来预料会在0.1以下的，慢了将近30倍。
6. lua，python。并列废柴。
