# 问题和算法描述 #

计算24点。

算法为递归枚举。在可选择的数集合中选择一个数（注意，枚举时不能两次重复选择相同的数，哪怕 在数列集合中出现两次），在算符表中选择一个算符。利用算符，当前值，选择的数，拼出表达式和计算结果，再递归调用自身。

尤其注意结果值的传递，这会大量减轻算法时间消耗。

# 测试三：24点 #

测试操作符为+-*/，测试数据为3 4 6 8，循环100次。

+------+--------+-------+------+----------+
| lang |filesize|runtime|memory|remark    |
+------+--------+-------+------+----------+
|go    |1184k   |  0.12s|  --  |          |
+------+--------+-------+------+----------+
|lua   |        |  2.27s|  764k|          |
+------+--------+-------+------+----------+
|python|        |  0.72s| 4056k|          |
+------+--------+-------+------+----------+
|cython|  47k   |  0.39s| 4056k|          |
+------+--------+-------+------+----------+
|pypy  |        |  0.74s|22760k|          |
+------+--------+-------+------+----------+
|guile |        |       |      |not done  |
+------+--------+-------+------+----------+
|racket|4117k   |  0.51s|41648k|          |
+------+--------+-------+------+----------+
|sbcl  |        |  1.3k |38572k|          |
+------+--------+-------+------+----------+

## 分析 ##

这次又是一个运算密集型问题，比较典型。其实对于这种问题，最好的是用lisp系的语言，例如sbcl和racket。不过实际执行下来却并非如此。

1. go，还是最优的。
2. cython，常年第二。
3. racket，常年第三，速度很快，但是内存是永远的痛。
4. python/pypy，其中pypy对速度并没有太大优化。
5. sbcl，算法不对
6. lua，算法不对
