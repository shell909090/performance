# 问题和算法描述 #

利用递归法求解fibonacci数列。

这是一个经典的问题，使用递归法求解，压力主要会集中在函数调用开销上。如果用迭代法求解，请另开一个目录。

# 结果 #

使用各种模式，计算fib(45)，比较速度和内存消耗。之所以使用这个，是因为f45刚刚好比int32小，C的计算时间又在10s左右，适合测量。

+---------+----------+---------+---------+--------+
|   lang  | filesize | runtime |  memory | remark |
+---------+----------+---------+---------+--------+
|    c    |   6.0    |  3.773  |  496.0  |        |
|  cython |   15.0   |  4.423  |  5320.0 |        |
| rpython |  199.0   |  6.985  |  5008.0 |        |
|    go   |  1242.0  |  7.441  |  880.0  |        |
|   sbcl  |  218.0   |  10.471 | 14496.0 |        |
|  racket |  4020.0  |  14.21  | 58160.0 |        |
|   pypy  | 40066.0  |  39.008 | 49100.0 |        |
|  guile  |   5.0    |  97.21  |  5460.0 |        |
|   lua   |  190.0   | 280.066 |  1028.0 |        |
|  python |  2931.0  | 316.898 |  5336.0 |        |
+---------+----------+---------+---------+--------+

## 第一集团军 ##

第一集团的速度和C差异不大，在至少一个方面有着绝对优势，在某些情况下应当成为选择的对象。

速度：

1. 速度方面，C是绝对的冠军。
2. cython的代码和C非常接近。事实上，如果不启动python相关部分，cython生成的就是C代码。
3. rpython的优化也非常好，无论是速度，内存占用。
4. go的速度勉强达标。

第一集团的备选语言基本有四种，rpython，cython，C，go。如果你一定要用lisp系列语言，racket编译后执行速度还算可以，sbcl经过优化后也差不多。美中不足是内存消耗都很大。

但是rpython其实不是一个选项，限制太大了。语言的限制到问题不大，但是库太少。连open都不能用，还用个p的库阿。

## 第二集团军 ##

然后是pypy，和python基本兼容，这很有吸引力。然而速度和第一集团很有差距，而且内存消耗太惊人了。

python和guile基本就是废柴级别，内存消耗不见小，速度慢到死。而且python比guile更加废。

lua的内存消耗倒是小，可惜执行速度太慢。
