# 编译型语言性能测试 #

# 测试一：fibonacci #

使用各种模式，计算fib(45)，比较速度和内存消耗。之所以使用这个，是因为这是比较经典的问题，CPU密集运算。f45刚刚好比int32小，C的计算时间又在10s左右，适合测量。

* C: 编译后5012B，时间消耗11s，内存消耗248k。
* go: 编译后1178k，时间消耗11.2s，内存消耗724k。
* lua: 时间消耗349s，内存消耗748k。
* python: 时间消耗307s，内存消耗3972k。
* cython + static type: 编译后11k，时间消耗10.47s，内存消耗4052k。
* pypy: 时间消耗56s，内存消耗21716k。而且内存消耗会逐步上升。
* rpython: 编译后176k，时间消耗7s，内存消耗4556k。
* guile: 时间消耗123.7s，内存消耗4260k。
* racket: 编译后4115k，时间消耗13.1s，内存消耗12864k。

## 第一集团军 ##

第一集团的速度和C差异不大，在至少一个方面有着绝对优势，在某些情况下应当成为选择的对象。

速度：

1. 速度方面，rpython称魁，而且编译后的大小很小，内存消耗和python差不多。如果你非常在意执行速度和开发时间，不妨多配点内存，使用rpython开发一些东西。
2. 次之则是C，go和cython。

内存消耗：

1. C在任何方面都是王者，无论是编译后大小，内存消耗，都无出其右。唯独速度被rpython超过。
2. go在内存使用上是第二名，而且开发方便。

编译后大小：

1. C
2. cython

第一集团的备选语言基本有四种，rpython，cython，C，go。如果你一定要用lisp系列语言，racket编译后大小一般，执行速度非常接近C和go。美中不足是内存消耗很大。

但是rpython其实不是一个选项，限制太大了。语言的限制到问题不大，但是库太少。连open都不能用，还用个p的库阿。

## 第二集团军 ##

然后是pypy，和python基本兼容，这很有吸引力。然而速度和第一集团很有差距，而且内存消耗太惊人了。

python和guile基本就是废柴级别，内存消耗不见小，速度慢到死。而且python比guile更加废。

lua的内存消耗倒是小，可惜执行速度太慢。

# 测试二：parse #

测试正则解析速度。

* go: 编译后1674k，时间消耗2.9s，内存消耗1216k。

# 测试三：24点 #

测试24点运算速度，循环100次。

* go: 编译后大小1184k，执行时间0.12s。时间太短，内存消耗测不出来。
* racket: 编译后大小4117k，执行时间0.57s，内存消耗41648k。
* sbcl: 执行时间1.3s，内存消耗38572k。
* lua: 执行时间2.27s，内存消耗764k。
* python: 执行时间2.27s，内存消耗4064k。
