# 编译型语言性能测试 #

# 测试一：fibonacci #

使用各种模式，计算fib(45)，比较速度和内存消耗。之所以使用这个，是因为这是比较经典的问题，CPU密集运算。f45刚刚好比int32小，C的计算时间又在10s左右，适合测量。

* C: 编译后5012B，时间消耗11s，内存消耗248k。
* go: 编译后1178k，时间消耗11.2s，内存消耗724k。
* lua: 时间消耗349s，内存消耗748k。
* python: 时间消耗307s，内存消耗3972k。
* cython + static type: 编译后11k，时间消耗10.47s，内存消耗4052k。
* pypy: 时间消耗56s，内存消耗21716k。而且内存消耗会逐步上升。
* rpython: 编译后176k，时间消耗7s，内存消耗4556k。
* guile: 时间消耗123.7s，内存消耗4260k。
* racket: 编译后4115k，时间消耗13.1s，内存消耗12864k。
* sbcl: 时间消耗12.4s，内存消耗10884k。

## 第一集团军 ##

第一集团的速度和C差异不大，在至少一个方面有着绝对优势，在某些情况下应当成为选择的对象。

速度：

1. 速度方面，rpython称魁，而且编译后的大小很小，内存消耗和python差不多。如果你非常在意执行速度和开发时间，不妨多配点内存，使用rpython开发一些东西。
2. 次之则是C，go和cython。
3. 再下面是sbcl和racket。

内存消耗：

1. C在任何方面都是王者，无论是编译后大小，内存消耗，都无出其右。唯独速度被rpython超过。
2. go在内存使用上是第二名，而且开发方便。

编译后大小：

1. C
2. cython

第一集团的备选语言基本有四种，rpython，cython，C，go。如果你一定要用lisp系列语言，racket编译后执行速度非常接近C和go。sbcl经过优化后也差不多。美中不足是内存消耗很大。

但是rpython其实不是一个选项，限制太大了。语言的限制到问题不大，但是库太少。连open都不能用，还用个p的库阿。

## 第二集团军 ##

然后是pypy，和python基本兼容，这很有吸引力。然而速度和第一集团很有差距，而且内存消耗太惊人了。

python和guile基本就是废柴级别，内存消耗不见小，速度慢到死。而且python比guile更加废。

lua的内存消耗倒是小，可惜执行速度太慢。

# 测试二：parse #

测试正则解析速度。

* go: 编译后1101k，时间消耗5.8s，内存消耗968k。
* lua: 时间消耗1.34s，内存消耗784k。
* python: 时间消耗0.92s，内存消耗3984k。
* cython: 编译后19k，时间消耗1.25s，内存消耗4056k。
* pypy: 时间消耗0.66s，内存消耗15076k。
* guile: 时间消耗15.6s，内存消耗5312k。
* racket: 时间消耗1.8s，内存消耗31832k。
* sbcl: 时间消耗0.39s，内存消耗37456k。

## 分析 ##

这次的结果和上面很不一样，go的速度优势一点都没有显现。有篇文章解释了这个现象，据说这是因为go的正则是用go写的，而python的正则是C写的。这次测试的性能，其实是库的优秀程度。

而且racket里，编译后速度反而下降了0.2s。

速度：

1. 最快的是sbcl，一点不需要优化。这是因为sbcl用的正则库是lisp写的，在使用的时候其实是用宏编译到了一起。不过内存占用吓人了点。
2. 次之是pypy，不愧是专业优化过的。一样，内存占用是大问题。
3. python，速度不慢。内存占用比较好接受。
4. cython，和python的内存占用差不多。
5. lua，速度一般，内存占用最优。
6. racket，速度不快，内存占用很大。

剩下两个，guile和go，就是废柴了。我们可以看到，在做这种事情的时候，最佳选择其实是python。

# 测试三：24点 #

测试24点运算速度，循环100次。

* go: 编译后大小1184k，执行时间0.12s。时间太短，内存消耗测不出来。
* racket: 编译后大小4117k，执行时间0.57s，内存消耗41648k。
* sbcl: 执行时间1.3s，内存消耗38572k。
* lua: 执行时间2.27s，内存消耗764k。
* python: 执行时间2.27s，内存消耗4064k。
