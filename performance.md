# 编译型语言性能测试 #

## 测试一：fibonacci ##

使用各种模式，计算fib(45)，比较速度和内存消耗。之所以使用这个，是因为这是比较经典的问题，CPU密集运算。f45刚刚好比int32小，C的计算时间又在10s左右，适合测量。
	 
## 测试二：parse ##

测试正则解析速度。

## 测试三：24点 ##

测试24点运算速度

## 测试四：字符拼接 ##

测试字符处理能力

## 测试反馈 ##

在测试一完成后，我们以测试一的结果为基准，测试其中最优秀的一些在其余测试中的表现。

# C #

我们使用C作为速度基准。

fib(45)编译后5012B，时间消耗11s，内存消耗248k。

# go #

fib(45)编译后1178K，时间消耗11s，内存消耗724k。

parse，编译后1674k，时间消耗2.9s，内存消耗1216k。

# lua #

fib(45)，时间消耗349s，内存消耗748k。

# python #

原生python，一点不修改，直接跑。

fib(45)，时间消耗307s，内存消耗3972k。

# cython + static type #

暂时跑不出来

# pypy #

原生python，一点不修改，用pypy跑。

fib(45)，时间消耗56s，内存消耗21716k。

# rpython #

使用rpython，编译后执行。

fib(45)编译后176k，时间消耗7s，内存消耗4556k。

# guile #

guile，编译后执行。注意，guile的编译只能编译为字节码，没有jit优化。

fib(45)，时间消耗123.7s，内存消耗4260k。

# racket #

racket，编译后执行。racket可以编译为执行文件，而且带有jit优化。

fib(45)编译后693k，时间消耗13.1s，内存消耗12864k。

# 评价 #

## 第一集团军 ##

第一集团的速度和C差异不大，在至少一个方面有着绝对优势，在某些情况下应当成为选择的对象。

* 速度：
  1. 速度方面，rpython称魁，而且编译后的大小很小，内存消耗和python差不多。如果你非常在意执行速度和开发时间，不妨多配点内存，使用rpython开发一些东西。
  2. 次之则是C和go。
* 内存消耗：
  1. C在任何方面都是王者，无论是编译后大小，内存消耗，都无出其右。唯独速度被rpython超过。而且开发太过困难。
  2. go在内存使用上是第二名，而且开发方便。
* 编译后大小：
  1. C
  2. rpython

第一集团的备选语言基本有三种，rpython，C，go。如果你一定要用lisp系列语言，racket编译后大小一般，执行速度非常接近C和go。美中不足是内存消耗很大。

但是rpython其实不是一个选项，限制太大了。语言的限制到问题不大，但是库太少。连open都不能用，还用个p的库阿。

## 第二集团军 ##

然后是pypy，和python基本兼容，这很有吸引力。然而速度和第一集团很有差距，而且内存消耗太惊人了。

python和guile基本就是废柴级别，内存消耗不见小，速度慢到死。而且python比guile更加废。

lua的内存消耗倒是小，可惜执行速度太慢。
